/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file was generated by "./hack/update-codegen.sh". Do not edit directly.
// directly.

package composite

import (
	"fmt"

	gcecloud "github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud"
	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/meta"
	computealpha "google.golang.org/api/compute/v0.alpha"
	computebeta "google.golang.org/api/compute/v0.beta"
	compute "google.golang.org/api/compute/v1"
	"google.golang.org/api/googleapi"
	compositemetrics "k8s.io/ingress-gce/pkg/composite/metrics"
	"k8s.io/klog"
	"k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
)

// Backend is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type Backend struct {
	// Specifies the balancing mode for this backend. For global HTTP(S) or
	// TCP/SSL load balancing, the default is UTILIZATION. Valid values are
	// UTILIZATION, RATE (for HTTP(S)) and CONNECTION (for TCP/SSL).
	//
	// For Internal Load Balancing, the default and only supported mode is
	// CONNECTION.
	BalancingMode string `json:"balancingMode,omitempty"`
	// A multiplier applied to the group's maximum servicing capacity (based
	// on UTILIZATION, RATE or CONNECTION). Default value is 1, which means
	// the group will serve up to 100% of its configured capacity (depending
	// on balancingMode). A setting of 0 means the group is completely
	// drained, offering 0% of its available Capacity. Valid range is
	// [0.0,1.0].
	//
	// This cannot be used for internal load balancing.
	CapacityScaler float64 `json:"capacityScaler,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// This field designates whether this is a failover backend. More than
	// one failover backend can be configured for a given BackendService.
	Failover bool `json:"failover,omitempty"`
	// The fully-qualified URL of a Instance Group resource. This instance
	// group defines the list of instances that serve traffic. Member
	// virtual machine instances from each instance group must live in the
	// same zone as the instance group itself. No two backends in a backend
	// service are allowed to use same Instance Group resource.
	//
	// Note that you must specify an Instance Group resource using the
	// fully-qualified URL, rather than a partial URL.
	//
	// When the BackendService has load balancing scheme INTERNAL, the
	// instance group must be within the same region as the BackendService.
	Group string `json:"group,omitempty"`
	// The max number of simultaneous connections for the group. Can be used
	// with either CONNECTION or UTILIZATION balancing modes. For CONNECTION
	// mode, either maxConnections or maxConnectionsPerInstance must be
	// set.
	//
	// This cannot be used for internal load balancing.
	MaxConnections int64 `json:"maxConnections,omitempty"`
	// The max number of simultaneous connections that a single backend
	// network endpoint can handle. This is used to calculate the capacity
	// of the group. Can be used in either CONNECTION or UTILIZATION
	// balancing modes. For CONNECTION mode, either maxConnections or
	// maxConnectionsPerEndpoint must be set.
	//
	// This cannot be used for internal load balancing.
	MaxConnectionsPerEndpoint int64 `json:"maxConnectionsPerEndpoint,omitempty"`
	// The max number of simultaneous connections that a single backend
	// instance can handle. This is used to calculate the capacity of the
	// group. Can be used in either CONNECTION or UTILIZATION balancing
	// modes. For CONNECTION mode, either maxConnections or
	// maxConnectionsPerInstance must be set.
	//
	// This cannot be used for internal load balancing.
	MaxConnectionsPerInstance int64 `json:"maxConnectionsPerInstance,omitempty"`
	// The max requests per second (RPS) of the group. Can be used with
	// either RATE or UTILIZATION balancing modes, but required if RATE
	// mode. For RATE mode, either maxRate or maxRatePerInstance must be
	// set.
	//
	// This cannot be used for internal load balancing.
	MaxRate int64 `json:"maxRate,omitempty"`
	// The max requests per second (RPS) that a single backend network
	// endpoint can handle. This is used to calculate the capacity of the
	// group. Can be used in either balancing mode. For RATE mode, either
	// maxRate or maxRatePerEndpoint must be set.
	//
	// This cannot be used for internal load balancing.
	MaxRatePerEndpoint float64 `json:"maxRatePerEndpoint,omitempty"`
	// The max requests per second (RPS) that a single backend instance can
	// handle. This is used to calculate the capacity of the group. Can be
	// used in either balancing mode. For RATE mode, either maxRate or
	// maxRatePerInstance must be set.
	//
	// This cannot be used for internal load balancing.
	MaxRatePerInstance float64 `json:"maxRatePerInstance,omitempty"`
	// Used when balancingMode is UTILIZATION. This ratio defines the CPU
	// utilization target for the group. The default is 0.8. Valid range is
	// [0.0, 1.0].
	//
	// This cannot be used for internal load balancing.
	MaxUtilization  float64  `json:"maxUtilization,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendService is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendService struct {
	// Version keeps track of the intended compute version for this BackendService.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// ResourceType keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	ResourceType meta.KeyType `json:"-"`

	// Lifetime of cookies in seconds if session_affinity is
	// GENERATED_COOKIE. If set to 0, the cookie is non-persistent and lasts
	// only until the end of the browser session (or equivalent). The
	// maximum allowed value for TTL is one day.
	//
	// When the load balancing scheme is INTERNAL, this field is not used.
	AffinityCookieTtlSec int64 `json:"affinityCookieTtlSec,omitempty"`
	// Directs request to an App Engine app. cloudFunctionBackend and
	// backends[] must be empty if this is set.
	AppEngineBackend *BackendServiceAppEngineBackend `json:"appEngineBackend,omitempty"`
	// The list of backends that serve this BackendService.
	Backends []*Backend `json:"backends,omitempty"`
	// Cloud CDN configuration for this BackendService.
	CdnPolicy *BackendServiceCdnPolicy `json:"cdnPolicy,omitempty"`
	// Directs request to a cloud function. appEngineBackend and backends[]
	// must be empty if this is set.
	CloudFunctionBackend *BackendServiceCloudFunctionBackend `json:"cloudFunctionBackend,omitempty"`
	ConnectionDraining   *ConnectionDraining                 `json:"connectionDraining,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// Headers that the HTTP/S load balancer should add to proxied requests.
	CustomRequestHeaders []string `json:"customRequestHeaders,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// If true, enable Cloud CDN for this BackendService.
	//
	// When the load balancing scheme is INTERNAL, this field is not used.
	EnableCDN      bool                          `json:"enableCDN,omitempty"`
	FailoverPolicy *BackendServiceFailoverPolicy `json:"failoverPolicy,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a BackendService. An up-to-date fingerprint
	// must be provided in order to update the BackendService.
	//
	// To see the latest fingerprint, make a get() request to retrieve a
	// BackendService.
	Fingerprint string `json:"fingerprint,omitempty"`
	// The list of URLs to the HttpHealthCheck or HttpsHealthCheck resource
	// for health checking this BackendService. Currently at most one health
	// check can be specified, and a health check is required for Compute
	// Engine backend services. A health check must not be specified for App
	// Engine backend and Cloud Function backend.
	//
	// For internal load balancing, a URL to a HealthCheck resource must be
	// specified instead.
	HealthChecks []string           `json:"healthChecks,omitempty"`
	Iap          *BackendServiceIAP `json:"iap,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of resource. Always compute#backendService for
	// backend services.
	Kind string `json:"kind,omitempty"`
	// Indicates whether the backend service will be used with internal or
	// external load balancing. A backend service created for one type of
	// load balancing cannot be used with the other. Possible values are
	// INTERNAL and EXTERNAL.
	LoadBalancingScheme string `json:"loadBalancingScheme,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// Deprecated in favor of portName. The TCP port to connect on the
	// backend. The default value is 80.
	//
	// This cannot be used for internal load balancing.
	Port int64 `json:"port,omitempty"`
	// Name of backend port. The same name should appear in the instance
	// groups referenced by this service. Required when the load balancing
	// scheme is EXTERNAL.
	//
	// When the load balancing scheme is INTERNAL, this field is not used.
	PortName string `json:"portName,omitempty"`
	// The protocol this BackendService uses to communicate with
	// backends.
	//
	// Possible values are HTTP, HTTPS, TCP, and SSL. The default is
	// HTTP.
	//
	// For internal load balancing, the possible values are TCP and UDP, and
	// the default is TCP.
	Protocol string `json:"protocol,omitempty"`
	// [Output Only] URL of the region where the regional backend service
	// resides. This field is not applicable to global backend services. You
	// must specify this field as part of the HTTP request URL. It is not
	// settable as a field in the request body.
	Region string `json:"region,omitempty"`
	// [Output Only] The resource URL for the security policy associated
	// with this backend service.
	SecurityPolicy string `json:"securityPolicy,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// Type of session affinity to use. The default is NONE.
	//
	// When the load balancing scheme is EXTERNAL, can be NONE, CLIENT_IP,
	// or GENERATED_COOKIE.
	//
	// When the load balancing scheme is INTERNAL, can be NONE, CLIENT_IP,
	// CLIENT_IP_PROTO, or CLIENT_IP_PORT_PROTO.
	//
	// When the protocol is UDP, this field is not used.
	SessionAffinity string `json:"sessionAffinity,omitempty"`
	// How many seconds to wait for the backend before considering it a
	// failed request. Default is 30 seconds.
	TimeoutSec               int64 `json:"timeoutSec,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// BackendServiceAppEngineBackend is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceAppEngineBackend struct {
	// Optional. App Engine app service name.
	AppEngineService string `json:"appEngineService,omitempty"`
	// Required. Project ID of the project hosting the app. This is the
	// project ID of this project. Reference to another project is not
	// allowed.
	TargetProject string `json:"targetProject,omitempty"`
	// Optional. Version of App Engine app service. When empty, App Engine
	// will do its normal traffic split.
	Version         string   `json:"version,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceCdnPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCdnPolicy struct {
	// The CacheKeyPolicy for this CdnPolicy.
	CacheKeyPolicy *CacheKeyPolicy `json:"cacheKeyPolicy,omitempty"`
	// Maximum number of seconds the response to a signed URL request will
	// be considered fresh. After this time period, the response will be
	// revalidated before being served. Defaults to 1hr (3600s). When
	// serving responses to signed URL requests, Cloud CDN will internally
	// behave as though all responses from this backend had a
	// ?Cache-Control: public, max-age=[TTL]? header, regardless of any
	// existing Cache-Control header. The actual headers served in responses
	// will not be altered.
	SignedUrlCacheMaxAgeSec int64 `json:"signedUrlCacheMaxAgeSec,omitempty,string"`
	// [Output Only] Names of the keys for signing request URLs.
	SignedUrlKeyNames []string `json:"signedUrlKeyNames,omitempty"`
	ForceSendFields   []string `json:"-"`
	NullFields        []string `json:"-"`
}

// BackendServiceCloudFunctionBackend is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceCloudFunctionBackend struct {
	// Required. A cloud function name. Special value ?*? represents all
	// cloud functions in the project.
	FunctionName string `json:"functionName,omitempty"`
	// Required. Project ID of the project hosting the cloud function.
	TargetProject   string   `json:"targetProject,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceFailoverPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceFailoverPolicy struct {
	// On failover or failback, this field indicates whether connection
	// drain will be honored. Setting this to true has the following effect:
	// connections to the old active pool are not drained. Connections to
	// the new active pool use the timeout of 10 min (currently fixed).
	// Setting to false has the following effect: both old and new
	// connections will have a drain timeout of 10 min.
	//
	// This can be set to true only if the protocol is TCP.
	//
	// The default is false.
	DisableConnectionDrainOnFailover bool `json:"disableConnectionDrainOnFailover,omitempty"`
	// This option is used only when no healthy VMs are detected in the
	// primary and backup instance groups. When set to true, traffic is
	// dropped. When set to false, new connections are sent across all VMs
	// in the primary group.
	//
	// The default is false.
	DropTrafficIfUnhealthy bool `json:"dropTrafficIfUnhealthy,omitempty"`
	// The value of the field must be in [0, 1]. If the ratio of the healthy
	// VMs in the primary backend is at or below this number, traffic
	// arriving at the load-balanced IP will be directed to the failover
	// backend.
	//
	// In case where 'failoverRatio' is not set or all the VMs in the backup
	// backend are unhealthy, the traffic will be directed back to the
	// primary backend in the "force" mode, where traffic will be spread to
	// the healthy VMs with the best effort, or to all VMs when no VM is
	// healthy.
	//
	// This field is only used with l4 load balancing.
	FailoverRatio   float64  `json:"failoverRatio,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// BackendServiceIAP is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceIAP struct {
	Enabled        bool   `json:"enabled,omitempty"`
	Oauth2ClientId string `json:"oauth2ClientId,omitempty"`
	// [Input Only] OAuth client info required to generate client id to be
	// used for IAP.
	Oauth2ClientInfo   *BackendServiceIAPOAuth2ClientInfo `json:"oauth2ClientInfo,omitempty"`
	Oauth2ClientSecret string                             `json:"oauth2ClientSecret,omitempty"`
	// [Output Only] SHA256 hash value for the field oauth2_client_secret
	// above.
	Oauth2ClientSecretSha256 string   `json:"oauth2ClientSecretSha256,omitempty"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// BackendServiceIAPOAuth2ClientInfo is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type BackendServiceIAPOAuth2ClientInfo struct {
	// Application name to be used in OAuth consent screen.
	ApplicationName string `json:"applicationName,omitempty"`
	// Name of the client to be generated. Optional - If not provided, the
	// name will be autogenerated by the backend.
	ClientName string `json:"clientName,omitempty"`
	// Developer's information to be used in OAuth consent screen.
	DeveloperEmailAddress string   `json:"developerEmailAddress,omitempty"`
	ForceSendFields       []string `json:"-"`
	NullFields            []string `json:"-"`
}

// CacheKeyPolicy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type CacheKeyPolicy struct {
	// If true, requests to different hosts will be cached separately.
	IncludeHost bool `json:"includeHost,omitempty"`
	// If true, http and https requests will be cached separately.
	IncludeProtocol bool `json:"includeProtocol,omitempty"`
	// If true, include query string parameters in the cache key according
	// to query_string_whitelist and query_string_blacklist. If neither is
	// set, the entire query string will be included. If false, the query
	// string will be excluded from the cache key entirely.
	IncludeQueryString bool `json:"includeQueryString,omitempty"`
	// Names of query string parameters to exclude in cache keys. All other
	// parameters will be included. Either specify query_string_whitelist or
	// query_string_blacklist, not both. '&' and '=' will be percent encoded
	// and not treated as delimiters.
	QueryStringBlacklist []string `json:"queryStringBlacklist,omitempty"`
	// Names of query string parameters to include in cache keys. All other
	// parameters will be excluded. Either specify query_string_whitelist or
	// query_string_blacklist, not both. '&' and '=' will be percent encoded
	// and not treated as delimiters.
	QueryStringWhitelist []string `json:"queryStringWhitelist,omitempty"`
	ForceSendFields      []string `json:"-"`
	NullFields           []string `json:"-"`
}

// ConnectionDraining is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ConnectionDraining struct {
	// Time for which instance will be drained (not accept new connections,
	// but still work to finish started).
	DrainingTimeoutSec int64    `json:"drainingTimeoutSec,omitempty"`
	ForceSendFields    []string `json:"-"`
	NullFields         []string `json:"-"`
}

// ForwardingRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type ForwardingRule struct {
	// Version keeps track of the intended compute version for this ForwardingRule.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// ResourceType keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	ResourceType meta.KeyType `json:"-"`

	// This field is used along with the backend_service field for internal
	// load balancing or with the target field for internal TargetInstance.
	// This field cannot be used with port or portRange fields.
	//
	// When the load balancing scheme is INTERNAL and protocol is TCP/UDP,
	// specify this field to allow packets addressed to any ports will be
	// forwarded to the backends configured with this forwarding rule.
	AllPorts bool `json:"allPorts,omitempty"`
	// This field is used along with the backend_service field for internal
	// load balancing or with the target field for internal TargetInstance.
	// If the field is set to TRUE, clients can access ILB from all regions.
	// Otherwise only allows access from clients in the same region as the
	// internal load balancer.
	AllowGlobalAccess bool `json:"allowGlobalAccess,omitempty"`
	// This field is only used for INTERNAL load balancing.
	//
	// For internal load balancing, this field identifies the BackendService
	// resource to receive the matched traffic.
	BackendService string `json:"backendService,omitempty"`
	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a ForwardingRule. Include the fingerprint in
	// patch request to ensure that you do not overwrite changes that were
	// applied from another concurrent request.
	//
	// To see the latest fingerprint, make a get() request to retrieve a
	// ForwardingRule.
	Fingerprint string `json:"fingerprint,omitempty"`
	// The IP address that this forwarding rule is serving on behalf
	// of.
	//
	// Addresses are restricted based on the forwarding rule's load
	// balancing scheme (EXTERNAL or INTERNAL) and scope (global or
	// regional).
	//
	// When the load balancing scheme is EXTERNAL, for global forwarding
	// rules, the address must be a global IP, and for regional forwarding
	// rules, the address must live in the same region as the forwarding
	// rule. If this field is empty, an ephemeral IPv4 address from the same
	// scope (global or regional) will be assigned. A regional forwarding
	// rule supports IPv4 only. A global forwarding rule supports either
	// IPv4 or IPv6.
	//
	// When the load balancing scheme is INTERNAL_SELF_MANAGED, this must be
	// a URL reference to an existing Address resource ( internal regional
	// static IP address), with a purpose of GCE_END_POINT and address_type
	// of INTERNAL.
	//
	// When the load balancing scheme is INTERNAL, this can only be an RFC
	// 1918 IP address belonging to the network/subnet configured for the
	// forwarding rule. By default, if this field is empty, an ephemeral
	// internal IP address will be automatically allocated from the IP range
	// of the subnet or network configured for this forwarding rule.
	//
	// An address can be specified either by a literal IP address or a URL
	// reference to an existing Address resource. The following examples are
	// all valid:
	// - 100.1.2.3
	// -
	// https://www.googleapis.com/compute/v1/projects/project/regions/region/addresses/address
	// - projects/project/regions/region/addresses/address
	// - regions/region/addresses/address
	// - global/addresses/address
	// - address
	IPAddress string `json:"IPAddress,omitempty"`
	// The IP protocol to which this rule applies. Valid options are TCP,
	// UDP, ESP, AH, SCTP or ICMP.
	//
	// When the load balancing scheme is INTERNAL, only TCP and UDP are
	// valid. When the load balancing scheme is INTERNAL_SELF_MANAGED, only
	// TCPis valid.
	IPProtocol string `json:"IPProtocol,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// The IP Version that will be used by this forwarding rule. Valid
	// options are IPV4 or IPV6. This can only be specified for an external
	// global forwarding rule.
	IpVersion string `json:"ipVersion,omitempty"`
	// [Output Only] Type of the resource. Always compute#forwardingRule for
	// Forwarding Rule resources.
	Kind string `json:"kind,omitempty"`
	// A fingerprint for the labels being applied to this resource, which is
	// essentially a hash of the labels set used for optimistic locking. The
	// fingerprint is initially generated by Compute Engine and changes
	// after every request to modify or update labels. You must always
	// provide an up-to-date fingerprint hash in order to update or change
	// labels.
	//
	// To see the latest fingerprint, make a get() request to retrieve a
	// ForwardingRule.
	LabelFingerprint string `json:"labelFingerprint,omitempty"`
	// Labels to apply to this resource. These can be later modified by the
	// setLabels method. Each label key/value pair must comply with RFC1035.
	// Label values may be empty.
	Labels map[string]string `json:"labels,omitempty"`
	// This signifies what the ForwardingRule will be used for and can only
	// take the following values: INTERNAL, INTERNAL_SELF_MANAGED, EXTERNAL.
	// The value of INTERNAL means that this will be used for Internal
	// Network Load Balancing (TCP, UDP). The value of INTERNAL_SELF_MANAGED
	// means that this will be used for Internal Global HTTP(S) LB. The
	// value of EXTERNAL means that this will be used for External Load
	// Balancing (HTTP(S) LB, External TCP/UDP LB, SSL Proxy)
	LoadBalancingScheme string `json:"loadBalancingScheme,omitempty"`
	// Name of the resource; provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// This field is not used for external load balancing.
	//
	// For INTERNAL and INTERNAL_SELF_MANAGED load balancing, this field
	// identifies the network that the load balanced IP should belong to for
	// this Forwarding Rule. If this field is not specified, the default
	// network will be used.
	Network string `json:"network,omitempty"`
	// This signifies the networking tier used for configuring this load
	// balancer and can only take the following values: PREMIUM ,
	// STANDARD.
	//
	// For regional ForwardingRule, the valid values are PREMIUM and
	// STANDARD. For GlobalForwardingRule, the valid value is PREMIUM.
	//
	// If this field is not specified, it is assumed to be PREMIUM. If
	// IPAddress is specified, this value must be equal to the networkTier
	// of the Address.
	NetworkTier string `json:"networkTier,omitempty"`
	// This field is used along with the target field for TargetHttpProxy,
	// TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
	// TargetPool, TargetInstance.
	//
	// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
	// addressed to ports in the specified range will be forwarded to
	// target. Forwarding rules with the same [IPAddress, IPProtocol] pair
	// must have disjoint port ranges.
	//
	// Some types of forwarding target have constraints on the acceptable
	// ports:
	// - TargetHttpProxy: 80, 8080
	// - TargetHttpsProxy: 443
	// - TargetTcpProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993,
	// 995, 1688, 1883, 5222
	// - TargetSslProxy: 25, 43, 110, 143, 195, 443, 465, 587, 700, 993,
	// 995, 1688, 1883, 5222
	// - TargetVpnGateway: 500, 4500
	PortRange string `json:"portRange,omitempty"`
	// This field is used along with the backend_service field for internal
	// load balancing.
	//
	// When the load balancing scheme is INTERNAL, a single port or a comma
	// separated list of ports can be configured. Only packets addressed to
	// these ports will be forwarded to the backends configured with this
	// forwarding rule.
	//
	// You may specify a maximum of up to 5 ports.
	Ports []string `json:"ports,omitempty"`
	// [Output Only] URL of the region where the regional forwarding rule
	// resides. This field is not applicable to global forwarding rules. You
	// must specify this field as part of the HTTP request URL. It is not
	// settable as a field in the request body.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// An optional prefix to the service name for this Forwarding Rule. If
	// specified, will be the first label of the fully qualified service
	// name.
	//
	// The label must be 1-63 characters long, and comply with RFC1035.
	// Specifically, the label must be 1-63 characters long and match the
	// regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
	// character must be a lowercase letter, and all following characters
	// must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	//
	// This field is only used for internal load balancing.
	ServiceLabel string `json:"serviceLabel,omitempty"`
	// [Output Only] The internal fully qualified service name for this
	// Forwarding Rule.
	//
	// This field is only used for internal load balancing.
	ServiceName string `json:"serviceName,omitempty"`
	// This field is only used for INTERNAL load balancing.
	//
	// For internal load balancing, this field identifies the subnetwork
	// that the load balanced IP should belong to for this Forwarding
	// Rule.
	//
	// If the network specified is in auto subnet mode, this field is
	// optional. However, if the network is in custom subnet mode, a
	// subnetwork must be specified.
	Subnetwork string `json:"subnetwork,omitempty"`
	// The URL of the target resource to receive the matched traffic. For
	// regional forwarding rules, this target must live in the same region
	// as the forwarding rule. For global forwarding rules, this target must
	// be a global load balancing resource. The forwarded traffic must be of
	// a type appropriate to the target object. For INTERNAL_SELF_MANAGED"
	// load balancing, only HTTP and HTTPS targets are valid.
	Target                   string `json:"target,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// HTTP2HealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HTTP2HealthCheck struct {
	// The value of the host header in the HTTP/2 health check request. If
	// left empty (default value), the IP on behalf of which this health
	// check is performed will be used.
	Host string `json:"host,omitempty"`
	// The TCP port number for the health check request. The default value
	// is 443. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in
	// port
	// is used for health checking.
	// USE_NAMED_PORT: The
	// portName
	// is used for health checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, HTTP2 health check follows behavior specified
	// in
	// port
	// and
	// portName
	// fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The request path of the HTTP/2 health check request. The default
	// value is /.
	RequestPath string `json:"requestPath,omitempty"`
	// The string to match anywhere in the first 1024 bytes of the response
	// body. If left empty (the default value), the status code determines
	// health. The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HTTPHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HTTPHealthCheck struct {
	// The value of the host header in the HTTP health check request. If
	// left empty (default value), the IP on behalf of which this health
	// check is performed will be used.
	Host string `json:"host,omitempty"`
	// The TCP port number for the health check request. The default value
	// is 80. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in
	// port
	// is used for health checking.
	// USE_NAMED_PORT: The
	// portName
	// is used for health checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, HTTP health check follows behavior specified
	// in
	// port
	// and
	// portName
	// fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The request path of the HTTP health check request. The default value
	// is /.
	RequestPath string `json:"requestPath,omitempty"`
	// The string to match anywhere in the first 1024 bytes of the response
	// body. If left empty (the default value), the status code determines
	// health. The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HTTPSHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HTTPSHealthCheck struct {
	// The value of the host header in the HTTPS health check request. If
	// left empty (default value), the IP on behalf of which this health
	// check is performed will be used.
	Host string `json:"host,omitempty"`
	// The TCP port number for the health check request. The default value
	// is 443. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in
	// port
	// is used for health checking.
	// USE_NAMED_PORT: The
	// portName
	// is used for health checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, HTTPS health check follows behavior specified
	// in
	// port
	// and
	// portName
	// fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The request path of the HTTPS health check request. The default value
	// is /.
	RequestPath string `json:"requestPath,omitempty"`
	// The string to match anywhere in the first 1024 bytes of the response
	// body. If left empty (the default value), the status code determines
	// health. The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// HealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HealthCheck struct {
	// Version keeps track of the intended compute version for this HealthCheck.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// ResourceType keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	ResourceType meta.KeyType `json:"-"`

	// How often (in seconds) to send a health check. The default value is 5
	// seconds.
	CheckIntervalSec int64 `json:"checkIntervalSec,omitempty"`
	// [Output Only] Creation timestamp in 3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// A so-far unhealthy instance will be marked healthy after this many
	// consecutive successes. The default value is 2.
	HealthyThreshold int64             `json:"healthyThreshold,omitempty"`
	Http2HealthCheck *HTTP2HealthCheck `json:"http2HealthCheck,omitempty"`
	HttpHealthCheck  *HTTPHealthCheck  `json:"httpHealthCheck,omitempty"`
	HttpsHealthCheck *HTTPSHealthCheck `json:"httpsHealthCheck,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// Type of the resource.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// [Output Only] Region where the health check resides. Not applicable
	// to global health checks.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink       string          `json:"selfLink,omitempty"`
	SslHealthCheck *SSLHealthCheck `json:"sslHealthCheck,omitempty"`
	TcpHealthCheck *TCPHealthCheck `json:"tcpHealthCheck,omitempty"`
	// How long (in seconds) to wait before claiming failure. The default
	// value is 5 seconds. It is invalid for timeoutSec to have greater
	// value than checkIntervalSec.
	TimeoutSec int64 `json:"timeoutSec,omitempty"`
	// Specifies the type of the healthCheck, either TCP, SSL, HTTP or
	// HTTPS. If not specified, the default is TCP. Exactly one of the
	// protocol-specific health check field must be specified, which must
	// match type field.
	Type           string          `json:"type,omitempty"`
	UdpHealthCheck *UDPHealthCheck `json:"udpHealthCheck,omitempty"`
	// A so-far healthy instance will be marked unhealthy after this many
	// consecutive failures. The default value is 2.
	UnhealthyThreshold       int64 `json:"unhealthyThreshold,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// HostRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type HostRule struct {
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// The list of host patterns to match. They must be valid hostnames,
	// except * will match any string of ([a-z0-9-.]*). In that case, * must
	// be the first character and must be followed in the pattern by either
	// - or ..
	Hosts []string `json:"hosts,omitempty"`
	// The name of the PathMatcher to use to match the path portion of the
	// URL if the hostRule matches the URL's host portion.
	PathMatcher     string   `json:"pathMatcher,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// PathMatcher is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PathMatcher struct {
	// The full or partial URL to the BackendService resource. This will be
	// used if none of the pathRules defined by this PathMatcher is matched
	// by the URL's path portion. For example, the following are all valid
	// URLs to a BackendService resource:
	// -
	// https://www.googleapis.com/compute/v1/projects/project/global/backendServices/backendService
	// - compute/v1/projects/project/global/backendServices/backendService
	//
	// - global/backendServices/backendService
	DefaultService string `json:"defaultService,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// The name to which this PathMatcher is referred by the HostRule.
	Name string `json:"name,omitempty"`
	// The list of path rules.
	PathRules       []*PathRule `json:"pathRules,omitempty"`
	ForceSendFields []string    `json:"-"`
	NullFields      []string    `json:"-"`
}

// PathRule is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type PathRule struct {
	// The list of path patterns to match. Each must start with / and the
	// only place a * is allowed is at the end following a /. The string fed
	// to the path matcher does not include any text after the first ? or #,
	// and those chars are not allowed here.
	Paths []string `json:"paths,omitempty"`
	// The URL of the BackendService resource if this rule is matched.
	Service         string   `json:"service,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// SSLHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type SSLHealthCheck struct {
	// The TCP port number for the health check request. The default value
	// is 443. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in
	// port
	// is used for health checking.
	// USE_NAMED_PORT: The
	// portName
	// is used for health checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, SSL health check follows behavior specified
	// in
	// port
	// and
	// portName
	// fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The application data to send once the SSL connection has been
	// established (default value is empty). If both request and response
	// are empty, the connection establishment alone will indicate health.
	// The request data can only be ASCII.
	Request string `json:"request,omitempty"`
	// The bytes to match against the beginning of the response data. If
	// left empty (the default value), any response will indicate health.
	// The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// TCPHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TCPHealthCheck struct {
	// The TCP port number for the health check request. The default value
	// is 80. Valid values are 1 through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Specifies how port is selected for health checking, can be one of
	// following values:
	// USE_FIXED_PORT: The port number in
	// port
	// is used for health checking.
	// USE_NAMED_PORT: The
	// portName
	// is used for health checking.
	// USE_SERVING_PORT: For NetworkEndpointGroup, the port specified for
	// each network endpoint is used for health checking. For other
	// backends, the port or named port specified in the Backend Service is
	// used for health checking.
	//
	//
	// If not specified, TCP health check follows behavior specified
	// in
	// port
	// and
	// portName
	// fields.
	PortSpecification string `json:"portSpecification,omitempty"`
	// Specifies the type of proxy header to append before sending data to
	// the backend, either NONE or PROXY_V1. The default is NONE.
	ProxyHeader string `json:"proxyHeader,omitempty"`
	// The application data to send once the TCP connection has been
	// established (default value is empty). If both request and response
	// are empty, the connection establishment alone will indicate health.
	// The request data can only be ASCII.
	Request string `json:"request,omitempty"`
	// The bytes to match against the beginning of the response data. If
	// left empty (the default value), any response will indicate health.
	// The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// TargetHttpProxy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TargetHttpProxy struct {
	// Version keeps track of the intended compute version for this TargetHttpProxy.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// ResourceType keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	ResourceType meta.KeyType `json:"-"`

	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of resource. Always compute#targetHttpProxy for
	// target HTTP proxies.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// [Output Only] URL of the region where the regional Target HTTP Proxy
	// resides. This field is not applicable to global Target HTTP Proxies.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// URL to the UrlMap resource that defines the mapping from URL to the
	// BackendService.
	UrlMap                   string `json:"urlMap,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// TargetHttpsProxy is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type TargetHttpsProxy struct {
	// Version keeps track of the intended compute version for this TargetHttpsProxy.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// ResourceType keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	ResourceType meta.KeyType `json:"-"`

	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of resource. Always compute#targetHttpsProxy for
	// target HTTPS proxies.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// Specifies the QUIC override policy for this TargetHttpsProxy
	// resource. This determines whether the load balancer will attempt to
	// negotiate QUIC with clients or not. Can specify one of NONE, ENABLE,
	// or DISABLE. Specify ENABLE to always enable QUIC, Enables QUIC when
	// set to ENABLE, and disables QUIC when set to DISABLE. If NONE is
	// specified, uses the QUIC policy with no user overrides, which is
	// equivalent to DISABLE. Not specifying this field is equivalent to
	// specifying NONE.
	QuicOverride string `json:"quicOverride,omitempty"`
	// [Output Only] URL of the region where the regional TargetHttpsProxy
	// resides. This field is not applicable to global TargetHttpsProxies.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// URLs to SslCertificate resources that are used to authenticate
	// connections between users and the load balancer. Currently, exactly
	// one SSL certificate must be specified.
	SslCertificates []string `json:"sslCertificates,omitempty"`
	// URL of SslPolicy resource that will be associated with the
	// TargetHttpsProxy resource. If not set, the TargetHttpsProxy resource
	// will not have any SSL policy configured.
	SslPolicy string `json:"sslPolicy,omitempty"`
	// A fully-qualified or valid partial URL to the UrlMap resource that
	// defines the mapping from URL to the BackendService. For example, the
	// following are all valid URLs for specifying a URL map:
	// -
	// https://www.googleapis.compute/v1/projects/project/global/urlMaps/url-map
	// - projects/project/global/urlMaps/url-map
	// - global/urlMaps/url-map
	UrlMap                   string `json:"urlMap,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// UDPHealthCheck is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UDPHealthCheck struct {
	// The UDP port number for the health check request. Valid values are 1
	// through 65535.
	Port int64 `json:"port,omitempty"`
	// Port name as defined in InstanceGroup#NamedPort#name. If both port
	// and port_name are defined, port takes precedence.
	PortName string `json:"portName,omitempty"`
	// Raw data of request to send in payload of UDP packet. It is an error
	// if this is empty. The request data can only be ASCII.
	Request string `json:"request,omitempty"`
	// The bytes to match against the beginning of the response data. It is
	// an error if this is empty. The response data can only be ASCII.
	Response        string   `json:"response,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

// UrlMap is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMap struct {
	// Version keeps track of the intended compute version for this UrlMap.
	// Note that the compute API's do not contain this field. It is for our
	// own bookkeeping purposes.
	Version meta.Version `json:"-"`
	// ResourceType keeps track of the intended type of the service (e.g. Global)
	// This is also an internal field purely for bookkeeping purposes
	ResourceType meta.KeyType `json:"-"`

	// [Output Only] Creation timestamp in RFC3339 text format.
	CreationTimestamp string `json:"creationTimestamp,omitempty"`
	// The URL of the BackendService resource if none of the hostRules
	// match.
	DefaultService string `json:"defaultService,omitempty"`
	// An optional description of this resource. Provide this property when
	// you create the resource.
	Description string `json:"description,omitempty"`
	// Fingerprint of this resource. A hash of the contents stored in this
	// object. This field is used in optimistic locking. This field will be
	// ignored when inserting a UrlMap. An up-to-date fingerprint must be
	// provided in order to update the UrlMap.
	//
	// To see the latest fingerprint, make a get() request to retrieve a
	// UrlMap.
	Fingerprint string `json:"fingerprint,omitempty"`
	// The list of HostRules to use against the URL.
	HostRules []*HostRule `json:"hostRules,omitempty"`
	// [Output Only] The unique identifier for the resource. This identifier
	// is defined by the server.
	Id uint64 `json:"id,omitempty,string"`
	// [Output Only] Type of the resource. Always compute#urlMaps for url
	// maps.
	Kind string `json:"kind,omitempty"`
	// Name of the resource. Provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means
	// the first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the
	// last character, which cannot be a dash.
	Name string `json:"name,omitempty"`
	// The list of named PathMatchers to use against the URL.
	PathMatchers []*PathMatcher `json:"pathMatchers,omitempty"`
	// [Output Only] URL of the region where the regional URL map resides.
	// This field is not applicable to global URL maps. You must specify
	// this field as part of the HTTP request URL. It is not settable as a
	// field in the request body.
	Region string `json:"region,omitempty"`
	// [Output Only] Server-defined URL for the resource.
	SelfLink string `json:"selfLink,omitempty"`
	// The list of expected URL mapping tests. Request to update this UrlMap
	// will succeed only if all of the test cases pass. You can specify a
	// maximum of 100 tests per UrlMap.
	Tests                    []*UrlMapTest `json:"tests,omitempty"`
	googleapi.ServerResponse `json:"-"`
	ForceSendFields          []string `json:"-"`
	NullFields               []string `json:"-"`
}

// UrlMapTest is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
type UrlMapTest struct {
	// Description of this test case.
	Description string `json:"description,omitempty"`
	// Host portion of the URL.
	Host string `json:"host,omitempty"`
	// Path portion of the URL.
	Path string `json:"path,omitempty"`
	// Expected BackendService resource the given URL should be mapped to.
	Service         string   `json:"service,omitempty"`
	ForceSendFields []string `json:"-"`
	NullFields      []string `json:"-"`
}

func CreateBackendService(backendService *BackendService, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "create", key.Region, key.Zone, string(backendService.Version))

	switch backendService.Version {
	case meta.VersionAlpha:
		alpha, err := backendService.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha BackendService %v", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().AlphaRegionBackendServices().Insert(ctx, key, alpha))
		default:
			return mc.Observe(cloud.Compute().AlphaBackendServices().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := backendService.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta BackendService %v", beta.Name)
		return mc.Observe(cloud.Compute().BetaBackendServices().Insert(ctx, key, beta))
	default:
		ga, err := backendService.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga BackendService %v", ga.Name)
		return mc.Observe(cloud.Compute().BackendServices().Insert(ctx, key, ga))
	}
}

func UpdateBackendService(backendService *BackendService, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "update", key.Region, key.Zone, string(backendService.Version))

	switch backendService.Version {
	case meta.VersionAlpha:
		alpha, err := backendService.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating alpha BackendService %v", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().AlphaRegionBackendServices().Update(ctx, key, alpha))
		default:
			return mc.Observe(cloud.Compute().AlphaBackendServices().Update(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := backendService.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating beta BackendService %v", beta.Name)
		return mc.Observe(cloud.Compute().BetaBackendServices().Update(ctx, key, beta))
	default:
		ga, err := backendService.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating ga BackendService %v", ga.Name)
		return mc.Observe(cloud.Compute().BackendServices().Update(ctx, key, ga))
	}
}

func GetBackendService(version meta.Version, cloud *gce.Cloud, key *meta.Key) (*BackendService, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("BackendService", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			gceObj, err = cloud.Compute().AlphaRegionBackendServices().Get(ctx, key)
		default:
			gceObj, err = cloud.Compute().AlphaBackendServices().Get(ctx, key)
		}
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaBackendServices().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().BackendServices().Get(ctx, key)
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	return ToBackendService(gceObj)
}

// ToBackendService converts a compute alpha, beta or GA
// BackendService into our composite type.
func ToBackendService(obj interface{}) (*BackendService, error) {
	backendService := &BackendService{}
	err := copyViaJSON(backendService, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to BackendService via JSON: %v", obj, err)
	}

	return backendService, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (backendService *BackendService) ToAlpha() (*computealpha.BackendService, error) {
	alpha := &computealpha.BackendService{}
	err := copyViaJSON(alpha, backendService)
	if err != nil {
		return nil, fmt.Errorf("error converting BackendService to compute alpha type via JSON: %v", err)
	}
	// Set force send fields. This is a temporary hack.
	if alpha.CdnPolicy != nil && alpha.CdnPolicy.CacheKeyPolicy != nil {
		alpha.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if alpha.Iap != nil {
		alpha.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (backendService *BackendService) ToBeta() (*computebeta.BackendService, error) {
	beta := &computebeta.BackendService{}
	err := copyViaJSON(beta, backendService)
	if err != nil {
		return nil, fmt.Errorf("error converting BackendService to compute beta type via JSON: %v", err)
	}
	// Set force send fields. This is a temporary hack.
	if beta.CdnPolicy != nil && beta.CdnPolicy.CacheKeyPolicy != nil {
		beta.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if beta.Iap != nil {
		beta.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (backendService *BackendService) ToGA() (*compute.BackendService, error) {
	ga := &compute.BackendService{}
	err := copyViaJSON(ga, backendService)
	if err != nil {
		return nil, fmt.Errorf("error converting BackendService to compute ga type via JSON: %v", err)
	}
	// Set force send fields. This is a temporary hack.
	if ga.CdnPolicy != nil && ga.CdnPolicy.CacheKeyPolicy != nil {
		ga.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if ga.Iap != nil {
		ga.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}

	return ga, nil
}

func CreateForwardingRule(forwardingRule *ForwardingRule, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "create", key.Region, key.Zone, string(forwardingRule.Version))

	switch forwardingRule.Version {
	case meta.VersionAlpha:
		alpha, err := forwardingRule.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha ForwardingRule %v", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().AlphaForwardingRules().Insert(ctx, key, alpha))
		default:
			return mc.Observe(cloud.Compute().AlphaGlobalForwardingRules().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := forwardingRule.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta ForwardingRule %v", beta.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().BetaForwardingRules().Insert(ctx, key, beta))
		default:
			return mc.Observe(cloud.Compute().BetaGlobalForwardingRules().Insert(ctx, key, beta))
		}
	default:
		ga, err := forwardingRule.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga ForwardingRule %v", ga.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().ForwardingRules().Insert(ctx, key, ga))
		default:
			return mc.Observe(cloud.Compute().GlobalForwardingRules().Insert(ctx, key, ga))
		}
	}
}

func GetForwardingRule(name string, version meta.Version, cloud *gce.Cloud, key *meta.Key) (*ForwardingRule, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("ForwardingRule", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			gceObj, err = cloud.Compute().AlphaForwardingRules().Get(ctx, key)
		default:
			gceObj, err = cloud.Compute().AlphaGlobalForwardingRules().Get(ctx, key)
		}
	case meta.VersionBeta:
		switch key.Type() {
		case meta.Regional:
			gceObj, err = cloud.Compute().BetaForwardingRules().Get(ctx, key)
		default:
			gceObj, err = cloud.Compute().BetaGlobalForwardingRules().Get(ctx, key)
		}
	default:
		switch key.Type() {
		case meta.Regional:
			gceObj, err = cloud.Compute().ForwardingRules().Get(ctx, key)
		default:
			gceObj, err = cloud.Compute().GlobalForwardingRules().Get(ctx, key)
		}
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	return ToForwardingRule(gceObj)
}

// ToForwardingRule converts a compute alpha, beta or GA
// ForwardingRule into our composite type.
func ToForwardingRule(obj interface{}) (*ForwardingRule, error) {
	forwardingRule := &ForwardingRule{}
	err := copyViaJSON(forwardingRule, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to ForwardingRule via JSON: %v", obj, err)
	}

	return forwardingRule, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) ToAlpha() (*computealpha.ForwardingRule, error) {
	alpha := &computealpha.ForwardingRule{}
	err := copyViaJSON(alpha, forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error converting ForwardingRule to compute alpha type via JSON: %v", err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) ToBeta() (*computebeta.ForwardingRule, error) {
	beta := &computebeta.ForwardingRule{}
	err := copyViaJSON(beta, forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error converting ForwardingRule to compute beta type via JSON: %v", err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (forwardingRule *ForwardingRule) ToGA() (*compute.ForwardingRule, error) {
	ga := &compute.ForwardingRule{}
	err := copyViaJSON(ga, forwardingRule)
	if err != nil {
		return nil, fmt.Errorf("error converting ForwardingRule to compute ga type via JSON: %v", err)
	}

	return ga, nil
}

func CreateHealthCheck(healthCheck *HealthCheck, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "create", key.Region, key.Zone, string(healthCheck.Version))

	switch healthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := healthCheck.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha HealthCheck %v", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().AlphaRegionHealthChecks().Insert(ctx, key, alpha))
		default:
			return mc.Observe(cloud.Compute().AlphaHealthChecks().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := healthCheck.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta HealthCheck %v", beta.Name)
		return mc.Observe(cloud.Compute().BetaHealthChecks().Insert(ctx, key, beta))
	default:
		ga, err := healthCheck.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga HealthCheck %v", ga.Name)
		return mc.Observe(cloud.Compute().HealthChecks().Insert(ctx, key, ga))
	}
}

func UpdateHealthCheck(healthCheck *HealthCheck, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "update", key.Region, key.Zone, string(healthCheck.Version))

	switch healthCheck.Version {
	case meta.VersionAlpha:
		alpha, err := healthCheck.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating alpha HealthCheck %v", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().AlphaRegionHealthChecks().Update(ctx, key, alpha))
		default:
			return mc.Observe(cloud.Compute().AlphaHealthChecks().Update(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := healthCheck.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating beta HealthCheck %v", beta.Name)
		return mc.Observe(cloud.Compute().BetaHealthChecks().Update(ctx, key, beta))
	default:
		ga, err := healthCheck.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating ga HealthCheck %v", ga.Name)
		return mc.Observe(cloud.Compute().HealthChecks().Update(ctx, key, ga))
	}
}

func GetHealthCheck(version meta.Version, cloud *gce.Cloud, key *meta.Key) (*HealthCheck, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("HealthCheck", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			gceObj, err = cloud.Compute().AlphaRegionHealthChecks().Get(ctx, key)
		default:
			gceObj, err = cloud.Compute().AlphaHealthChecks().Get(ctx, key)
		}
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaHealthChecks().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().HealthChecks().Get(ctx, key)
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	return ToHealthCheck(gceObj)
}

// ToHealthCheck converts a compute alpha, beta or GA
// HealthCheck into our composite type.
func ToHealthCheck(obj interface{}) (*HealthCheck, error) {
	healthCheck := &HealthCheck{}
	err := copyViaJSON(healthCheck, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to HealthCheck via JSON: %v", obj, err)
	}

	return healthCheck, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (healthCheck *HealthCheck) ToAlpha() (*computealpha.HealthCheck, error) {
	alpha := &computealpha.HealthCheck{}
	err := copyViaJSON(alpha, healthCheck)
	if err != nil {
		return nil, fmt.Errorf("error converting HealthCheck to compute alpha type via JSON: %v", err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (healthCheck *HealthCheck) ToBeta() (*computebeta.HealthCheck, error) {
	beta := &computebeta.HealthCheck{}
	err := copyViaJSON(beta, healthCheck)
	if err != nil {
		return nil, fmt.Errorf("error converting HealthCheck to compute beta type via JSON: %v", err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (healthCheck *HealthCheck) ToGA() (*compute.HealthCheck, error) {
	ga := &compute.HealthCheck{}
	err := copyViaJSON(ga, healthCheck)
	if err != nil {
		return nil, fmt.Errorf("error converting HealthCheck to compute ga type via JSON: %v", err)
	}

	return ga, nil
}

func CreateTargetHttpProxy(targetHttpProxy *TargetHttpProxy, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "create", key.Region, key.Zone, string(targetHttpProxy.Version))

	switch targetHttpProxy.Version {
	case meta.VersionAlpha:
		alpha, err := targetHttpProxy.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha TargetHttpProxy %v", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().AlphaRegionTargetHttpProxies().Insert(ctx, key, alpha))
		default:
			return mc.Observe(cloud.Compute().AlphaTargetHttpProxies().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := targetHttpProxy.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta TargetHttpProxy %v", beta.Name)
		return mc.Observe(cloud.Compute().BetaTargetHttpProxies().Insert(ctx, key, beta))
	default:
		ga, err := targetHttpProxy.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga TargetHttpProxy %v", ga.Name)
		return mc.Observe(cloud.Compute().TargetHttpProxies().Insert(ctx, key, ga))
	}
}

func GetTargetHttpProxy(version meta.Version, cloud *gce.Cloud, key *meta.Key) (*TargetHttpProxy, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpProxy", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			gceObj, err = cloud.Compute().AlphaRegionTargetHttpProxies().Get(ctx, key)
		default:
			gceObj, err = cloud.Compute().AlphaTargetHttpProxies().Get(ctx, key)
		}
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaTargetHttpProxies().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().TargetHttpProxies().Get(ctx, key)
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	return ToTargetHttpProxy(gceObj)
}

// ToTargetHttpProxy converts a compute alpha, beta or GA
// TargetHttpProxy into our composite type.
func ToTargetHttpProxy(obj interface{}) (*TargetHttpProxy, error) {
	targetHttpProxy := &TargetHttpProxy{}
	err := copyViaJSON(targetHttpProxy, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to TargetHttpProxy via JSON: %v", obj, err)
	}

	return targetHttpProxy, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) ToAlpha() (*computealpha.TargetHttpProxy, error) {
	alpha := &computealpha.TargetHttpProxy{}
	err := copyViaJSON(alpha, targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting TargetHttpProxy to compute alpha type via JSON: %v", err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) ToBeta() (*computebeta.TargetHttpProxy, error) {
	beta := &computebeta.TargetHttpProxy{}
	err := copyViaJSON(beta, targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting TargetHttpProxy to compute beta type via JSON: %v", err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (targetHttpProxy *TargetHttpProxy) ToGA() (*compute.TargetHttpProxy, error) {
	ga := &compute.TargetHttpProxy{}
	err := copyViaJSON(ga, targetHttpProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting TargetHttpProxy to compute ga type via JSON: %v", err)
	}

	return ga, nil
}

func CreateTargetHttpsProxy(targetHttpsProxy *TargetHttpsProxy, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "create", key.Region, key.Zone, string(targetHttpsProxy.Version))

	switch targetHttpsProxy.Version {
	case meta.VersionAlpha:
		alpha, err := targetHttpsProxy.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha TargetHttpsProxy %v", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().AlphaRegionTargetHttpsProxies().Insert(ctx, key, alpha))
		default:
			return mc.Observe(cloud.Compute().AlphaTargetHttpsProxies().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := targetHttpsProxy.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta TargetHttpsProxy %v", beta.Name)
		return mc.Observe(cloud.Compute().BetaTargetHttpsProxies().Insert(ctx, key, beta))
	default:
		ga, err := targetHttpsProxy.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga TargetHttpsProxy %v", ga.Name)
		return mc.Observe(cloud.Compute().TargetHttpsProxies().Insert(ctx, key, ga))
	}
}

func GetTargetHttpsProxy(version meta.Version, cloud *gce.Cloud, key *meta.Key) (*TargetHttpsProxy, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("TargetHttpsProxy", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			gceObj, err = cloud.Compute().AlphaRegionTargetHttpsProxies().Get(ctx, key)
		default:
			gceObj, err = cloud.Compute().AlphaTargetHttpsProxies().Get(ctx, key)
		}
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaTargetHttpsProxies().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().TargetHttpsProxies().Get(ctx, key)
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	return ToTargetHttpsProxy(gceObj)
}

// ToTargetHttpsProxy converts a compute alpha, beta or GA
// TargetHttpsProxy into our composite type.
func ToTargetHttpsProxy(obj interface{}) (*TargetHttpsProxy, error) {
	targetHttpsProxy := &TargetHttpsProxy{}
	err := copyViaJSON(targetHttpsProxy, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to TargetHttpsProxy via JSON: %v", obj, err)
	}

	return targetHttpsProxy, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) ToAlpha() (*computealpha.TargetHttpsProxy, error) {
	alpha := &computealpha.TargetHttpsProxy{}
	err := copyViaJSON(alpha, targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting TargetHttpsProxy to compute alpha type via JSON: %v", err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) ToBeta() (*computebeta.TargetHttpsProxy, error) {
	beta := &computebeta.TargetHttpsProxy{}
	err := copyViaJSON(beta, targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting TargetHttpsProxy to compute beta type via JSON: %v", err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (targetHttpsProxy *TargetHttpsProxy) ToGA() (*compute.TargetHttpsProxy, error) {
	ga := &compute.TargetHttpsProxy{}
	err := copyViaJSON(ga, targetHttpsProxy)
	if err != nil {
		return nil, fmt.Errorf("error converting TargetHttpsProxy to compute ga type via JSON: %v", err)
	}

	return ga, nil
}

func CreateUrlMap(urlMap *UrlMap, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "create", key.Region, key.Zone, string(urlMap.Version))

	switch urlMap.Version {
	case meta.VersionAlpha:
		alpha, err := urlMap.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha UrlMap %v", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().AlphaRegionUrlMaps().Insert(ctx, key, alpha))
		default:
			return mc.Observe(cloud.Compute().AlphaUrlMaps().Insert(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := urlMap.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta UrlMap %v", beta.Name)
		return mc.Observe(cloud.Compute().BetaUrlMaps().Insert(ctx, key, beta))
	default:
		ga, err := urlMap.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga UrlMap %v", ga.Name)
		return mc.Observe(cloud.Compute().UrlMaps().Insert(ctx, key, ga))
	}
}

func UpdateUrlMap(urlMap *UrlMap, cloud *gce.Cloud, key *meta.Key) error {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "update", key.Region, key.Zone, string(urlMap.Version))

	switch urlMap.Version {
	case meta.VersionAlpha:
		alpha, err := urlMap.ToAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating alpha UrlMap %v", alpha.Name)
		switch key.Type() {
		case meta.Regional:
			return mc.Observe(cloud.Compute().AlphaRegionUrlMaps().Update(ctx, key, alpha))
		default:
			return mc.Observe(cloud.Compute().AlphaUrlMaps().Update(ctx, key, alpha))
		}
	case meta.VersionBeta:
		beta, err := urlMap.ToBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating beta UrlMap %v", beta.Name)
		return mc.Observe(cloud.Compute().BetaUrlMaps().Update(ctx, key, beta))
	default:
		ga, err := urlMap.ToGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating ga UrlMap %v", ga.Name)
		return mc.Observe(cloud.Compute().UrlMaps().Update(ctx, key, ga))
	}
}

func GetUrlMap(version meta.Version, cloud *gce.Cloud, key *meta.Key) (*UrlMap, error) {
	ctx, cancel := gcecloud.ContextWithCallTimeout()
	defer cancel()
	mc := compositemetrics.NewMetricContext("UrlMap", "get", key.Region, key.Zone, string(version))

	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		switch key.Type() {
		case meta.Regional:
			gceObj, err = cloud.Compute().AlphaRegionUrlMaps().Get(ctx, key)
		default:
			gceObj, err = cloud.Compute().AlphaUrlMaps().Get(ctx, key)
		}
	case meta.VersionBeta:
		gceObj, err = cloud.Compute().BetaUrlMaps().Get(ctx, key)
	default:
		gceObj, err = cloud.Compute().UrlMaps().Get(ctx, key)
	}
	if err != nil {
		return nil, mc.Observe(err)
	}
	return ToUrlMap(gceObj)
}

// ToUrlMap converts a compute alpha, beta or GA
// UrlMap into our composite type.
func ToUrlMap(obj interface{}) (*UrlMap, error) {
	urlMap := &UrlMap{}
	err := copyViaJSON(urlMap, obj)
	if err != nil {
		return nil, fmt.Errorf("could not copy object %+v to UrlMap via JSON: %v", obj, err)
	}

	return urlMap, nil
}

// ToAlpha converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func (urlMap *UrlMap) ToAlpha() (*computealpha.UrlMap, error) {
	alpha := &computealpha.UrlMap{}
	err := copyViaJSON(alpha, urlMap)
	if err != nil {
		return nil, fmt.Errorf("error converting UrlMap to compute alpha type via JSON: %v", err)
	}

	return alpha, nil
}

// ToBeta converts our composite type into an beta type.
// This beta type can be used in GCE API calls.
func (urlMap *UrlMap) ToBeta() (*computebeta.UrlMap, error) {
	beta := &computebeta.UrlMap{}
	err := copyViaJSON(beta, urlMap)
	if err != nil {
		return nil, fmt.Errorf("error converting UrlMap to compute beta type via JSON: %v", err)
	}

	return beta, nil
}

// ToGA converts our composite type into an ga type.
// This ga type can be used in GCE API calls.
func (urlMap *UrlMap) ToGA() (*compute.UrlMap, error) {
	ga := &compute.UrlMap{}
	err := copyViaJSON(ga, urlMap)
	if err != nil {
		return nil, fmt.Errorf("error converting UrlMap to compute ga type via JSON: %v", err)
	}

	return ga, nil
}
