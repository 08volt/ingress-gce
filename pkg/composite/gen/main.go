/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Generator for GCE compute wrapper code. You must regenerate the code after
// modifying this file:
//
//   $ ./hack/update_codegen.sh

package main

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
	"text/template"
	"time"

	compositemeta "k8s.io/ingress-gce/pkg/composite/meta"
)

const (
	gofmt = "gofmt"
)

// gofmtContent runs "gofmt" on the given contents.
func gofmtContent(r io.Reader) string {
	cmd := exec.Command(gofmt, "-s")
	out := &bytes.Buffer{}
	cmd.Stdin = r
	cmd.Stdout = out
	cmdErr := &bytes.Buffer{}
	cmd.Stderr = cmdErr

	if err := cmd.Run(); err != nil {
		fmt.Fprintf(os.Stderr, cmdErr.String())
		panic(err)
	}
	return out.String()
}

func genHeader(wr io.Writer) {
	const text = `/*
Copyright {{.Year}} The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file was generated by "go run gen/main.go". Do not edit directly.
// directly.

package composite
import (
	"encoding/json"
	"fmt"

	"k8s.io/klog"
	computealpha "google.golang.org/api/compute/v0.alpha"
	computebeta "google.golang.org/api/compute/v0.beta"
	compute "google.golang.org/api/compute/v1"
	"google.golang.org/api/googleapi"
	"k8s.io/kubernetes/pkg/cloudprovider/providers/gce"
	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/meta"
)
`
	tmpl := template.Must(template.New("header").Parse(text))
	values := map[string]string{
		"Year": fmt.Sprintf("%v", time.Now().Year()),
	}
	if err := tmpl.Execute(wr, values); err != nil {
		panic(err)
	}

	fmt.Fprintf(wr, "\n\n")
}

func genTestHeader(wr io.Writer) {
	const text = `/*
Copyright {{.Year}} The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// This file was generated by "go run gen/main.go". Do not edit directly.
// directly.

package composite
import (
	"fmt"
	"reflect"
	"testing"

	"github.com/kr/pretty"
	computealpha "google.golang.org/api/compute/v0.alpha"
	computebeta "google.golang.org/api/compute/v0.beta"
	compute "google.golang.org/api/compute/v1"
)
`
	tmpl := template.Must(template.New("testHeader").Parse(text))
	values := map[string]string{
		"Year": fmt.Sprintf("%v", time.Now().Year()),
	}
	if err := tmpl.Execute(wr, values); err != nil {
		panic(err)
	}

	fmt.Fprintf(wr, "\n\n")
}

// genTypes() generates all of the composite structs.
func genTypes(wr io.Writer) {
	const text = `
{{ $backtick := "` + "`" + `" }}
{{- range .All}}
	// {{.Name}} is a composite type wrapping the Alpha, Beta, and GA methods for its GCE equivalent
	type {{.Name}} struct {
		{{- if .IsMainService}}
			// Version keeps track of the intended compute version for this {{.Name}}.
			// Note that the compute API's do not contain this field. It is for our
			// own bookkeeping purposes.
			Version meta.Version {{$backtick}}json:"-"{{$backtick}}
		{{- end}}

		{{- range .Fields}}
			{{- if eq .Name "Id"}}
				{{.Name}} {{.GoType}} {{$backtick}}json:"{{.JsonName}},omitempty,string"{{$backtick}}
			{{- else if .JsonStringOverride}}
				{{.Name}} {{.GoType}} {{$backtick}}json:"{{.JsonName}},omitempty,string"{{$backtick}}
			{{- else}}
				{{.Name}} {{.GoType}} {{$backtick}}json:"{{.JsonName}},omitempty"{{$backtick}}
			{{- end}}
		{{- end}}
		{{- if .IsMainService}}
			googleapi.ServerResponse {{$backtick}}json:"-"{{$backtick}}
		{{- end}}
		ForceSendFields []string {{$backtick}}json:"-"{{$backtick}}
		NullFields []string {{$backtick}}json:"-"{{$backtick}}
}
{{- end}}
`
	data := struct {
		All []compositemeta.ApiService
	}{compositemeta.AllApiServices}

	tmpl := template.Must(template.New("types").Parse(text))
	if err := tmpl.Execute(wr, data); err != nil {
		panic(err)
	}
}

// genFuncs() generates helper methods attached to composite structs.
// TODO: (shance) generated CRUD functions should take a meta.Key object to allow easier use of global and regional resources
func genFuncs(wr io.Writer) {
	const text = `
{{$All := .All}}
{{$Versions := .Versions}}

{{range $type := $All}}
{{if .IsMainService}}
	func Create{{.Name}}({{.VarName}} *{{.Name}}, cloud *gce.Cloud) error {
	switch {{.VarName}}.Version {
	case meta.VersionAlpha:
		alpha, err := {{.VarName}}.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating alpha {{.Name}} %v", alpha.Name)
		return cloud.CreateAlphaGlobal{{.Name}}(alpha)
	case meta.VersionBeta:
		beta, err := {{.VarName}}.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating beta {{.Name}} %v", beta.Name)
		return cloud.CreateBetaGlobal{{.Name}}(beta)
	default:
		ga, err := {{.VarName}}.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Creating ga {{.Name}} %v", ga.Name)
		return cloud.CreateGlobal{{.Name}}(ga)
	}
}

{{if .HasUpdate}}
func Update{{.Name}}({{.VarName}} *{{.Name}}, cloud *gce.Cloud) error {
	switch {{.VarName}}.Version {
	case meta.VersionAlpha:
		alpha, err := {{.VarName}}.toAlpha()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating alpha {{.Name}} %v", alpha.Name)
		return cloud.UpdateAlphaGlobal{{.Name}}(alpha)
	case meta.VersionBeta:
		beta, err := {{.VarName}}.toBeta()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating beta {{.Name}} %v", beta.Name)
		return cloud.UpdateBetaGlobal{{.Name}}(beta)
	default:
		ga, err := {{.VarName}}.toGA()
		if err != nil {
			return err
		}
		klog.V(3).Infof("Updating ga {{.Name}} %v", ga.Name)
		return cloud.UpdateGlobal{{.Name}}(ga)
	}
}
{{- end}}

func Get{{.Name}}(name string, version meta.Version, cloud *gce.Cloud) (*{{.Name}}, error) {
	var gceObj interface{}
	var err error
	switch version {
	case meta.VersionAlpha:
		gceObj, err = cloud.GetAlphaGlobal{{.Name}}(name)
	case meta.VersionBeta:
		gceObj, err = cloud.GetBetaGlobal{{.Name}}(name)
	default:
		gceObj, err = cloud.GetGlobal{{.Name}}(name)
	}
	if err != nil {
		return nil, err
	}
	return to{{.Name}}(gceObj)
}

// to{{.Name}} converts a compute alpha, beta or GA
// {{.Name}} into our composite type.
func to{{.Name}}(obj interface{}) (*{{.Name}}, error) {
	be := &{{.Name}}{}
	bytes, err := json.Marshal(obj)
	if err != nil {
		return nil, fmt.Errorf("could not marshal object %+v to JSON: %v", obj, err)
	}
	err = json.Unmarshal(bytes, be)
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling to {{.Name}}: %v", err)
	}
	return be, nil
}

{{- range $version, $extension := $.Versions}}
{{$lower := $version | ToLower}}
// to{{$version}} converts our composite type into an alpha type.
// This alpha type can be used in GCE API calls.
func ({{$type.VarName}} *{{$type.Name}}) to{{$version}}() (*compute{{$extension}}.{{$type.Name}}, error) {
	bytes, err := json.Marshal({{$type.VarName}})
	if err != nil {
		return nil, fmt.Errorf("error marshalling {{$type.Name}} to JSON: %v", err)
	}
	{{$version | ToLower}} := &compute{{$extension}}.{{$type.Name}}{}
	err = json.Unmarshal(bytes, {{$lower}})
	if err != nil {
		return nil, fmt.Errorf("error unmarshalling {{$type.Name}} JSON to compute {{$lower}} type: %v", err)
	}

	{{- if eq $type.Name "BackendService"}}
	// Set force send fields. This is a temporary hack.
	if {{$lower}}.CdnPolicy != nil && {{$lower}}.CdnPolicy.CacheKeyPolicy != nil {
		{{$lower}}.CdnPolicy.CacheKeyPolicy.ForceSendFields = []string{"IncludeHost", "IncludeProtocol", "IncludeQueryString", "QueryStringBlacklist", "QueryStringWhitelist"}
	}
	if {{$lower}}.Iap != nil {
		{{$lower}}.Iap.ForceSendFields = []string{"Enabled", "Oauth2ClientId", "Oauth2ClientSecret"}
	}
	{{- end}}	

	return {{$lower}}, nil
}
{{- end}}


{{- end}}
{{- end}}
`
	data := struct {
		All      []compositemeta.ApiService
		Versions map[string]string
	}{compositemeta.AllApiServices, compositemeta.Versions}

	funcMap := template.FuncMap{
		"ToLower": strings.ToLower,
	}

	tmpl := template.Must(template.New("funcs").Funcs(funcMap).Parse(text))
	if err := tmpl.Execute(wr, data); err != nil {
		panic(err)
	}
}

// genTests() generates all of the tests
func genTests(wr io.Writer) {
	const text = `
// compareFields verifies that two fields in a struct have the same relevant metadata.
// Note: This comparison ignores field offset, index, and pkg path, all of which don't matter.
func compareFields(s1, s2 reflect.StructField) error {
	if s1.Name != s2.Name {
		return fmt.Errorf("field %s name = %q, want %q", s1.Name, s1.Name, s2.Name)
	}
	if s1.Tag != s2.Tag {
		return fmt.Errorf("field %s tag = %q, want %q", s1.Name, s1.Tag, s2.Tag)
	}
	if s1.Type.Name() != s2.Type.Name() {
		return fmt.Errorf("field %s type = %q, want %q", s1.Name, s1.Type.Name(), s2.Type.Name())
	}
	return nil
}

// typeEquality is a generic function that checks type equality.
func typeEquality(t1, t2 reflect.Type) error {
	t1Fields, t2Fields := make(map[string]bool), make(map[string]bool)
	for i := 0; i < t1.NumField(); i++ {
		t1Fields[t1.Field(i).Name] = true
	}
	for i := 0; i < t2.NumField(); i++ {
		t2Fields[t2.Field(i).Name] = true
	}
	if !reflect.DeepEqual(t1Fields, t2Fields) {
		return fmt.Errorf("type = %+v, want %+v", t1Fields, t2Fields)
	}
	for n := range t1Fields {
		f1, _ := t1.FieldByName(n)
		f2, _ := t2.FieldByName(n)
		if err := compareFields(f1, f2); err != nil {
			return err
		}
	}
	return nil
}

{{ $All := .All}}
{{range $type := $All}}
		{{- if .IsMainService}}
			func Test{{.Name}}(t *testing.T) {
	// Use reflection to verify that our composite type contains all the
	// same fields as the alpha type.
	compositeType := reflect.TypeOf({{.Name}}{})
	alphaType := reflect.TypeOf(computealpha.{{.Name}}{})

	// For the composite type, remove the Version field from consideration
	compositeTypeNumFields := compositeType.NumField() - 1
	if compositeTypeNumFields != alphaType.NumField() {
		t.Fatalf("%v should contain %v fields. Got %v", alphaType.Name(), alphaType.NumField(), compositeTypeNumFields)
	}

	// Compare all the fields by doing a lookup since we can't guarantee that they'll be in the same order
	for i := 1; i < compositeType.NumField(); i++ {
		lookupField, found := alphaType.FieldByName(compositeType.Field(i).Name)
		if !found {
			t.Fatal(fmt.Errorf("Field %v not present in alpha type %v", compositeType.Field(i), alphaType))
		}
		if err := compareFields(compositeType.Field(i), lookupField); err != nil {
			t.Fatal(err)
		}
	}
}

func TestTo{{.Name}}(t *testing.T) {
	testCases := []struct {
		input    interface{}
		expected *{{.Name}}
	}{
		{
			computealpha.{{.Name}}{},
			&{{.Name}}{},
		},
		{
			computebeta.{{.Name}}{},
			&{{.Name}}{},
		},
		{
			compute.{{.Name}}{},
			&{{.Name}}{},
		},
	}
	for _, testCase := range testCases {
		result, _ := to{{.Name}}(testCase.input)
		if !reflect.DeepEqual(result, testCase.expected) {
			t.Fatalf("to{{.Name}}(input) = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(testCase.input), pretty.Sprint(result), pretty.Sprint(testCase.expected))
		}
	}
}

{{range $version, $extension := $.Versions}}
func Test{{$type.Name}}To{{$version}}(t *testing.T) {
	composite := {{$type.Name}}{}
	expected := &compute{{$extension}}.{{$type.Name}}{}
	result, err := composite.to{{$version}}()
	if err != nil {
		t.Fatalf("{{$type.Name}}.to{{$version}}() error: %v", err)
	}

	if !reflect.DeepEqual(result, expected) {
		t.Fatalf("{{$type.Name}}.to{{$version}}() = \ninput = %s\n%s\nwant = \n%s", pretty.Sprint(composite), pretty.Sprint(result), pretty.Sprint(expected))
	}
}
{{- end}}

{{- else}}

func Test{{.Name}}(t *testing.T) {
	compositeType := reflect.TypeOf({{.Name}}{})
	alphaType := reflect.TypeOf(computealpha.{{.Name}}{})
	if err := typeEquality(compositeType, alphaType); err != nil {
		t.Fatal(err)
	}
}
		{{- end}}
{{- end}}
`
	data := struct {
		All      []compositemeta.ApiService
		Versions map[string]string
	}{compositemeta.AllApiServices, compositemeta.Versions}

	funcMap := template.FuncMap{
		"ToLower": strings.ToLower,
	}

	tmpl := template.Must(template.New("tests").Funcs(funcMap).Parse(text))
	if err := tmpl.Execute(wr, data); err != nil {
		panic(err)
	}
}

func main() {
	out := &bytes.Buffer{}
	testOut := &bytes.Buffer{}

	genHeader(out)
	genTypes(out)
	genFuncs(out)

	genTestHeader(testOut)
	genTests(testOut)

	var err error
	err = ioutil.WriteFile("./pkg/composite/composite.go", []byte(gofmtContent(out)), 0644)
	if err != nil {
		panic(err)
	}
	err = ioutil.WriteFile("./pkg/composite/composite_test.go", []byte(gofmtContent(testOut)), 0644)
	if err != nil {
		panic(err)
	}
}
